<h1>About</h1>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h2>組員名單</h2>
<p><span>40723104   <a href="https://s40723104.github.io/cd2020/content/index.html">https://s40723104.github.io/cd2020/content/index.html</a></span><br/><span><span>40723107</span></span><span>   <a href="https://s40723107.github.io/cd2020/content/index.html">https://s40723107.github.io/cd2020/content/index.html</a></span><br/><span><span>40723114</span></span><span> </span><span>(group leader)  <a href="https://s40723114.github.io/cd2020/content/index.html">https://s40723114.github.io/cd2020/content/index.html</a></span><br/><span><span>40723115</span></span><span>   <a href="https://s40723115.github.io/cd2020/content/index.html">https://s40723115.github.io/cd2020/content/index.html</a></span><br/><span><span>40723118</span></span><span>  <a href="https://s40723118.github.io/cd2020/content/index.html">https://s40723118.github.io/cd2020/content/index.html</a></span><br/><span><span>40723122 </span></span><span> <a href="https://s40723122.github.io/cd2020/content/index.html">https://s40723122.github.io/cd2020/content/index.html</a></span><br/><span>40723123  <a href="https://s40723123.github.io/cd2020/content/index.html">https://s40723123.github.io/cd2020/content/index.html</a></span><br/><span>40723140  <a href="https://s40723140.github.io/cd2020/content/index.html">https://s40723140.github.io/cd2020/content/index.html</a></span><br/><span><span>40723149</span></span><span>  <a href="https://s40723149.github.io/cd2020/content/index.html">https://s40723149.github.io/cd2020/content/index.html</a></span><br/><span>40723151 <a href="https://s40723151.github.io/cd2020/content/index.html"><span> </span>https://s40723151.github.io/cd2020/content/index.html</a></span><br/><span><span>40723153</span></span><span> <a href="https://s40723153.github.io/cd2020"><span> </span>https://s40723153.github.io/cd2020</a></span><br/><span><span>40723154</span></span><span>  <a href="https://s40723154.github.io/cd2020/content/index.html">https://s40723154.github.io/cd2020/content/index.html</a></span><br/><span><span>40723155</span></span><span>  <a href="https://s40723155.github.io/cd2020/content/index.html">https://s40723155.github.io/cd2020/content/index.html</a></span></p>
<p></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4></h4>
<h1>WORK</h1>
<h2>Work1</h2>
<h3>建立可攜系統</h3>
<p><span>先創可攜系統的目錄 </span><span>”CD2020” </span><span>，在 </span><span>CD2020 </span><span>的目錄下新增 </span><span>”data”</span><span>。</span></p>
<p>Python 3.8.2<br/>到 <span><a href="https://www.python.org/downloads/release/python-382/">https://www.python.org/downloads/release/python-382/</a> </span>搜尋<span>”Windows x86-64 executable installer”</span>並下載<span>”Windows x86-64 executable installer”</span>，下載完後，執行<span>python-3.8.2-amd64.exe</span></p>
<p><span>PortableGit：<br/><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> 下載 64-bit Git for Windows Portable 安裝在 data 目錄下</span></p>
<p><span>MSYS2：<br/><a href="https://www.msys2.org/">https://www.msys2.org/</a> 下載 msys2-x86_64-20190524.exe 並安裝在 data/msys64 的目錄下</span></p>
<p><span>SciTE：<a href="https://www.scintilla.org/SciTEDownload.html">https://www.scintilla.org/SciTEDownload.html</a> 下載 full 64-bit download，解壓縮檔案至 data/wscite432，就是可以直接執行的 Scite.exe 編輯器，若希望以 UtF-8 編碼開啟文件，就必須啟用 Options 下拉式功能表中的 Global Options File（同 SciTEGlobal.properties 檔案）其中的預設值 code.page=0 （為Windows 內定的 Big-5 編碼）修改設定為 code.page=65001，表示使用使 UTF-8 編碼，若要開啟即時更新內容，將load.on.activate=1 前面的井字號拿掉，就會即時更新了（SciTE 須重啟）<br/><img caption="false" height="538" src="https://s40723150.github.io/cd2020/images/SciTE_UTF-8.gif" width="400"/><br/>修改成 UTF-8 編碼<br/><img caption="false" height="476" src="https://s40723150.github.io/cd2020/images/set_scite_loadon.gif" width="400"/><br/>修改成即時更新</span></p>
<p>在<span>data</span>目錄下新增<span>”home”</span>目錄，開啟SciTE</p>
<p><span>start.bat(儲存在CD2020目錄底下)</span></p>
<div>
<div class="syntaxhighlighter html" id="highlighter_245854">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
<div class="line number5 index4 alt2">5</div>
<div class="line number6 index5 alt1">6</div>
<div class="line number7 index6 alt2">7</div>
<div class="line number8 index7 alt1">8</div>
<div class="line number9 index8 alt2">9</div>
<div class="line number10 index9 alt1">10</div>
<div class="line number11 index10 alt2">11</div>
<div class="line number12 index11 alt1">12</div>
<div class="line number13 index12 alt2">13</div>
<div class="line number14 index13 alt1">14</div>
<div class="line number15 index14 alt2">15</div>
<div class="line number16 index15 alt1">16</div>
<div class="line number17 index16 alt2">17</div>
<div class="line number18 index17 alt1">18</div>
<div class="line number19 index18 alt2">19</div>
<div class="line number20 index19 alt1">20</div>
<div class="line number21 index20 alt2">21</div>
<div class="line number22 index21 alt1">22</div>
<div class="line number23 index22 alt2">23</div>
<div class="line number24 index23 alt1">24</div>
<div class="line number25 index24 alt2">25</div>
<div class="line number26 index25 alt1">26</div>
<div class="line number27 index26 alt2">27</div>
<div class="line number28 index27 alt1">28</div>
<div class="line number29 index28 alt2">29</div>
<div class="line number30 index29 alt1">30</div>
<div class="line number31 index30 alt2">31</div>
<div class="line number32 index31 alt1">32</div>
<div class="line number33 index32 alt2">33</div>
<div class="line number34 index33 alt1">34</div>
<div class="line number35 index34 alt2">35</div>
<div class="line number36 index35 alt1">36</div>
<div class="line number37 index36 alt2">37</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="html plain">@echo off</code></div>
<div class="line number2 index1 alt1"><code class="html plain">set Disk=y</code></div>
<div class="line number3 index2 alt2"><code class="html plain">subst %Disk%: "data"</code></div>
<div class="line number4 index3 alt1"> </div>
<div class="line number5 index4 alt2"><code class="html plain">%Disk%:</code></div>
<div class="line number6 index5 alt1"> </div>
<div class="line number7 index6 alt2"><code class="html plain">set HomePath=%Disk%:\home</code></div>
<div class="line number8 index7 alt1"><code class="html plain">set HomeDrive=%Disk%:\home</code></div>
<div class="line number9 index8 alt2"><code class="html plain">set Home=%Disk%:\home</code></div>
<div class="line number10 index9 alt1"><code class="html plain">set USERPROFILE=%Disk%:\home</code></div>
<div class="line number11 index10 alt2"> </div>
<div class="line number12 index11 alt1"><code class="html plain">REM 將系統 Python 程式的 io 設為 utf-8</code></div>
<div class="line number13 index12 alt2"><code class="html plain">set PYTHONIOENCODING="utf-8"</code></div>
<div class="line number14 index13 alt1"> </div>
<div class="line number15 index14 alt2"><code class="html plain">#REM for putty</code></div>
<div class="line number16 index15 alt1"><code class="html plain">#Set GIT_HOME=%CDisk%:\portablegit\bin\</code></div>
<div class="line number17 index16 alt2"><code class="html plain">#Set GIT_SSH=%Disk%:\putty\plink.exe</code></div>
<div class="line number18 index17 alt1"> </div>
<div class="line number19 index18 alt2"><code class="html plain">set PYTHONPATH=%Disk%:\py382\DLLs;%Disk%:\py382\Lib;%Disk%:\py382\Lib\site-packages;</code></div>
<div class="line number20 index19 alt1"><code class="html plain">set PYTHONHOME=%Disk%:\py382</code></div>
<div class="line number21 index20 alt2"> </div>
<div class="line number22 index21 alt1"><code class="html plain">set path_python=%Disk%:\py382;%Disk%:\py382\Scripts;</code></div>
<div class="line number23 index22 alt2"><code class="html plain">set path_msys2=%Disk%:\msys64\mingw64\bin;</code></div>
<div class="line number24 index23 alt1"><code class="html plain">set path_git=%Disk%:\portablegit\bin;</code></div>
<div class="line number25 index24 alt2"><code class="html plain">set path_tcc=%Disk%:\tcc;</code></div>
<div class="line number26 index25 alt1"> </div>
<div class="line number27 index26 alt2"><code class="html plain">path=%Disk%:;%path_python%;%path_msys2%;%path_git%;%path_tcc%;</code></div>
<div class="line number28 index27 alt1"> </div>
<div class="line number29 index28 alt2"><code class="html plain">start /MIN cmd.exe</code></div>
<div class="line number30 index29 alt1"><code class="html plain">start /MIN cmd.exe</code></div>
<div class="line number31 index30 alt2"><code class="html plain">start /MIN cmd.exe</code></div>
<div class="line number32 index31 alt1"><code class="html plain">start /MIN cmd.exe</code></div>
<div class="line number33 index32 alt2"> </div>
<div class="line number34 index33 alt1"><code class="html plain">start /MIN %Disk%:\wscite432\wscite\SciTE.exe</code></div>
<div class="line number35 index34 alt2"><code class="html plain">start /MIN %Disk%:\wscite432\wscite\SciTE.exe</code></div>
<div class="line number36 index35 alt1"> </div>
<div class="line number37 index36 alt2"><code class="html plain">Exit</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>stop.bat(儲存在CD2020目錄底下)</p>
<div>
<div class="syntaxhighlighter html" id="highlighter_621139">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
<div class="line number5 index4 alt2">5</div>
<div class="line number6 index5 alt1">6</div>
<div class="line number7 index6 alt2">7</div>
<div class="line number8 index7 alt1">8</div>
<div class="line number9 index8 alt2">9</div>
<div class="line number10 index9 alt1">10</div>
<div class="line number11 index10 alt2">11</div>
<div class="line number12 index11 alt1">12</div>
<div class="line number13 index12 alt2">13</div>
<div class="line number14 index13 alt1">14</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="html plain">@echo off</code></div>
<div class="line number2 index1 alt1"><code class="html plain">set Disk=y</code></div>
<div class="line number3 index2 alt2"><code class="html plain">path=%PATH%;</code></div>
<div class="line number4 index3 alt1"> </div>
<div class="line number5 index4 alt2"><code class="html plain">taskkill /IM python.exe /F</code></div>
<div class="line number6 index5 alt1"><code class="html plain">taskkill /IM pythonw.exe /F</code></div>
<div class="line number7 index6 alt2"><code class="html plain">taskkill /IM scite.exe /F</code></div>
<div class="line number8 index7 alt1"> </div>
<div class="line number9 index8 alt2"><code class="html plain">REM 終止虛擬硬碟與目錄的對應</code></div>
<div class="line number10 index9 alt1"><code class="html plain">subst %Disk%: /D</code></div>
<div class="line number11 index10 alt2"><code class="html plain">REM 關閉 cmd 指令視窗</code></div>
<div class="line number12 index11 alt1"><code class="html plain">taskkill /IM cmd.exe /F</code></div>
<div class="line number13 index12 alt2"> </div>
<div class="line number14 index13 alt1"><code class="html plain">EXIT</code></div>
</div>
</td>
</tr>
</tbody>
</table>
<p><span>MSYS2：</span><a href="https://www.msys2.org/"><br/>https://www.msys2.org/</a><span><span> </span>下載<span> </span></span><span>msys2-x86_64-20190524.exe<span> </span></span><span>並執行</span><span>選擇CD2020\data\msys64的目錄，最後反選 Run MSYS2 64bit now選項，finish<br/><span>等PortableGit安裝完成重啟可攜，測試。</span></span></p>
</div>
</div>
<p><span>Tiny C Compiler：</span><span><a href="https://github.com/TinyCC/tinycc">https://github.com/TinyCC/tinycc</a> git clone 整個倉儲到 data 目錄下並命名目錄為 tcc</span></p>
<p><span>Jupyterlab：<a href="https://github.com/jupyterlab/jupyterlab">https://github.com/jupyterlab/jupyterlab</a> pip install jupyterlab==2.0.1 自動執行安裝</span></p>
<p>安裝pip：<br/>到<a href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a>頁面，滑鼠右鍵另存新檔到CD2020/data執行<span>使用pip安裝flask,bs4,xml,elican, mrkdown,flask_cors,leo模組</span><br/><span>安裝過程若出現紅字，請重新執行一次模組安裝指令，應該會正常安裝。</span></p>
<div>Fossil SCM：<span><a href="https://www.fossil-scm.org/">https://www.fossil-scm.org/</a> 下載 fossil scm 解壓縮後將 fossil.exe 放到 data 目錄下</span></div>
<p><span>Flutter：<a href="https://github.com/flutter/flutter">https://github.com/flutter/flutter </a> (在 data 目錄底下 git clone https://github.com/flutter/flutter.git -b stable)</span></p>
<p>CoppeliaSim：<span><a href="https://www.coppeliarobotics.com/winVersions">https://www.coppeliarobotics.com/winVersions</a> 下載 <a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_0_0_Win.zip">CoppeliaSim Edu, Binaries</a> 解壓縮後放到 data 目錄下</span></p>
<p>home/home_mdecourse：存放 ssh 的資料和.gitconfig</p>
<p>tmp：放 clone 下來的倉儲</p>
<p>ShareX：<a href="https://getsharex.com/downloads/">https://getsharex.com/downloads/</a></p>
<p>putty：<a href="http://mde.tw/cp2019/content/USB%20%E7%A8%8B%E5%BC%8F%E7%B3%BB%E7%B5%B1.html">老師整理的 putty</a> <span>下載</span><a href="https://github.com/s40723150/cd2020/raw/master/downloads/putty.7z">putty</a><span>放到data裡面，把之前的ssh和.gitconfig放到home裡面測試是否可以成功用ssh推送資料。</span></p>
<p></p>
<p>基礎可攜系統<a href="https://drive.google.com/file/d/15b_VXiaXYLqaMuMAvAeZKegX4eSkiU70/view">下載<br/></a><a href="https://drive.google.com/open?id=1Ghi3rTB-HIZEn49PWgfOap7aha2UZvK9">有配置Webots<br/></a><a href="https://drive.google.com/open?id=1TN1NWb0rj675Ld-mb4QRNn-0ECRb2eZG">有配置Webots+</a><span><a href="https://drive.google.com/open?id=1TN1NWb0rj675Ld-mb4QRNn-0ECRb2eZG">CoppeliaSim</a>(</span>CoppeliaSim V4.0.0<span>，含</span><span>xelatex)<br/>P.S. 可以下載可攜系統的leo都已經升級到6.2.1版本了</span></p>
<h2>Work2</h2>
<h3>瞭解四輪機器人</h3>
<p>首先翻譯我們覺得比較有實用的內容</p>
<p>可碰撞物體<span>(Collidable objects)</span></p>
<p>可碰撞對像是可以測試互相碰撞的對象，即將記錄碰撞狀態的對象。這並不意味著它們將對碰撞做出響應（即可響應），這有所不同。可碰撞的對象包括：</p>
<p><span> </span>假人</p>
<p>形狀</p>
<p>超頻樹</p>
<p>點雲</p>
<p>由於基於點，因此虛擬對象和點雲只能與<span>OC</span>樹（基於體積）碰撞。</p>
<p>集合也是可碰撞的，因為它們可能包含可碰撞的對象。</p>
<p>可碰撞對象可以分別啟用或禁用其可碰撞屬性（默認情況下，對於非純形狀，<span>OC</span>樹和點雲啟用）。可以在對象的公共屬性中或通過<span>sim.setObjectSpecialProperty API</span>函數進行設置。</p>
<p>此外，可碰撞對象可以根據其相關的模型屬性（如果它們是模型的一部分）被覆蓋其可碰撞屬性。</p>
<p><span> </span></p>
<p>可測對象<span>(Measurable objects)</span></p>
<p>可測量對像是可用於與其他可測量對象進行最小距離計算的對象。它們包括：</p>
<p><span> </span>假人</p>
<p>形狀</p>
<p>超頻樹</p>
<p>點雲</p>
<p>集合也是可測量的，因為它們可能包含可測量的對象。</p>
<p>可測量對象可以分別啟用或禁用其可測量屬性（默認情況下，對於非純形狀，<span>OC</span>樹和點雲啟用）。可以在對象的公共屬性中或通過<span>sim.setObjectSpecialProperty API</span>函數進行設置。</p>
<p>此外，可測量對象可以根據其相關的模型屬性（如果它們是模型的一部分）而覆蓋其可測量屬性。</p>
<p><span> </span></p>
<p>可檢測物體<span>(Detectable objects)</span></p>
<p>可檢測物體是可以被接近傳感器檢測到的物體。它們包括：</p>
<p>假人</p>
<p>形狀</p>
<p>超頻樹</p>
<p>點雲</p>
<p>由於是基於點的虛擬和點雲，因此射線類型或隨機類型的接近傳感器無法檢測到。</p>
<p>可以通過所有接近傳感器，或僅通過特定類型的接近傳感器或接近傳感器的子類別來檢測可檢測到的物體，如下所示：</p>
<p>超聲波接近傳感器</p>
<p>紅外接近傳感器</p>
<p>激光接近傳感器</p>
<p>電感式接近傳感器</p>
<p>電容式接近傳感器</p>
<p>集合也是可檢測的，因為它們可能包含可檢測的對象。</p>
<p>可檢測的對象可以分別啟用或禁用其可檢測屬性，並且對於所有類型的接近傳感器（默認情況下對非純形狀啟用）都啟用此屬性。可以在對象的公共屬性中或通過<span>sim.setObjectSpecialProperty API</span>函數進行設置。</p>
<p>此外，可檢測對象可以根據其相關的模型屬性（如果它們是模型的一部分）被覆蓋其可檢測屬性。</p>
<p><span> </span></p>
<p>可渲染對象<span>(Renderable objects)</span></p>
<p>可渲染對像是視覺傳感器可以看到或檢測到的對象。它們包括：</p>
<p>形狀</p>
<p>路徑（但是必須啟用路徑整形功能）</p>
<p>圖形（僅呈現非靜態<span>3D</span>曲線）</p>
<p>超頻樹</p>
<p>點雲</p>
<p>集合也是可渲染的，因為它們可能包含可渲染的對象。</p>
<p>您可以使可渲染對象僅由特定的視覺傳感器看到可渲染對像還可以分別啟用或禁用其<span>renderable</span>屬性（默認情況下啟用，純圖形除外）。可以在對象的公共屬性中或通過<span>sim.setObjectSpecialProperty API</span>函數進行設置。</p>
<p>此外，可渲染對象可以根據其相關的模型屬性（如果它們是模型的一部分）而使其可渲染屬性被覆蓋。</p>
<p><span> </span></p>
<p>可視對象<span>(Viewable objects)</span></p>
<p>可見對像是可以瀏覽，查看或可以顯示某些圖像內容的對象。它們包括：</p>
<p>攝影機</p>
<p>視覺傳感器</p>
<p>可視對象可以與將顯示其圖像內容的視圖關聯。</p>
<p><span> </span></p>
<p>虛擬功能<span>(Dummy functions)</span></p>
<p>假人是多用途的對象。它們可以具有非常特定的功能，也可以僅用作輔助對象。以下偽函數是常見的：</p>
<p>用作點或參考系統：當您要跟蹤場景中特定點的位置和<span>/</span>或方向時，就是這種情況。虛擬位置可以與形狀頂點的位置匹配，例如，可以精確定位形狀：在頂點編輯模式下，從頂點創建虛擬對象，然後將形狀附加到虛擬對象（使虛擬對象成為父對象））。並且可以通過虛擬對象來操縱<span>/</span>定位形狀，該虛擬對象的位置與所選頂點相同。</p>
<p>用作模型的代理或支持對象：通過將對象標記為模型基礎標誌來定義模型。任何對像都可以作為模型的基礎，但是虛擬對像是該模型的首選對象。</p>
<p>用作標記點：例如，在評估機器人的工作空間時，可以在不同的時間間隔將假人放置在與機器人末端執行器相同的坐標上，最後可以提取所有添加的假人的凸包並顯示。有關更多詳細信息，請參閱凸包計算部分。</p>
<p>用於指定逆運動學計算中的末端執行器和末端執行器目標位置<span>/</span>方向：逆運動學計算模塊處理運動鏈。每個鏈都有一個基礎對象和一個提示對象。尖端對象必須是假人，並且用戶經常將尖端假人定位和定向為與機器人的末端執行器重合。同時，為了以逆運動學模式移動運動鏈，需要機器人末端執行器的目標位置<span>/</span>方向。同樣，將虛擬對像用作目標對象。</p>
<p>用於為動態模擬的機制創建循環閉合約束：有關更多詳細信息，請參考設計動態模擬的部分。</p>
<p>用作路徑跟隨對象：虛擬對像是唯一可以分配留在路徑上（在路徑上自由，自由滑動）或跟隨路徑位置（固定在路徑上，沿著路徑在其當前固有位置固定）的對象。</p>
<p><img alt="" height="135" src="https://s40723114.github.io/cd2020ag1/images/%E8%99%9B%E6%93%AC1.jpg" width="614"/></p>
<p></p>
<p>虛擬屬性<span>(Dummy properties)</span></p>
<p>虛擬屬性是場景對象屬性對話框的一部分，該對話框位於<span>[</span>菜單欄<span>-&gt;</span>工具<span>-&gt;</span>場景對象屬性<span>]</span>。還可以通過雙按場景層次結構中的對像圖標或單按其工具欄按鈕來打開對話框：</p>
<p><img alt="" height="37" src="https://s40723114.github.io/cd2020ag1/images/%E8%99%9B%E6%93%AC2.jpg" width="38"/></p>
<p>在場景對象屬性對話框中，單按“虛擬”按鈕以顯示虛擬對話框（“虛擬”按鈕僅在最後選擇的是虛擬對象時出現）。該對話框顯示最後選擇的虛擬對象的設置和參數。如果選擇了多個假人，則可以將某些參數從最後選擇的假人復製到其他選定的假人（適用於選擇按鈕）：</p>
<p><img alt="" height="419" src="https://s40723114.github.io/cd2020ag1/images/%E8%99%9B%E6%93%AC3.jpg" width="396"/></p>
<p>鏈接的虛擬對象：鏈接到此對象的虛擬對象。鏈接的虛擬對象（在場景和場景層次中，通過鏈接它們的彩色段很容易識別）具有特殊的屬性和行為，有關更多詳細信息，請參閱下一項。</p>
<p>鏈接類型：鏈接類型將指定仿真期間鏈接的虛擬對象的行為。如果指定了“動力學，重疊約束”，則這兩個虛擬實體將嘗試重疊各自的位置<span>/</span>方向以創建動力學迴路閉合約束。如果指定了<span>IK</span>，則指定了刀尖目標，則兩個鏈接的虛擬對象形成了用於反向運動學計算的刀尖目標對。</p>
<p>遵循主路徑的方向（唯一副路徑）：如果選中，則以路徑作為主（唯一副路徑）的虛擬對象將遵循該路徑的最接近貝塞爾曲線點的方向（而不是位置）。 另請參閱<span>sim.followPath API</span>函數（使用<span>sim.followPath</span>函數，不需要將虛擬對象與路徑作為主從關係）。</p>
<p>遵循主路徑<span>(</span>唯一主路徑<span>)</span>：如果選中該選項，並且假人的主路徑是路徑對象，則假人的位置和方向將由該路徑自動計算（即將從路徑的<span>Bezier</span>點進行插值）。</p>
<p>有兩種選擇：路徑自由或路徑固定。另請參閱<span>sim.followPath API</span>函數（使用<span>sim.followPath</span>函數，不需要將虛擬對象與路徑作為對象）。</p>
<p>路徑上自由：選中該對像後，會將具有路徑對像作為對象的虛擬對象分配為留在路徑上（保持與路徑的<span>Bezier</span>點相同的位置和方向），但可以沿路徑自由移動。它可以通過對像操縱模式沿路徑移動，也可以由逆運動學模塊自動沿路徑引導。</p>
<p>固定在路徑上：選中此選項後，會將具有路徑對像作為對象的虛擬對象分配為留在路徑上（與路徑的<span>Bezier</span>點保持相同的位置和方向），位於路徑的固有位置。一個比喻是在過山車的履帶部分上的貨車（將貨車拉起的初始部分）。在這種情況下，可以指定從路徑位置偏移的距離。</p>
<p>偏移量：將假人分配到路徑上的固定位置時，與路徑位置的距離偏移量。如果要創建履帶，則履帶的第一個墊板（剛性元件）將位於偏移量<span>0</span>處，第二個墊板將位於偏移量<span>x</span>處，第二個墊板將位於偏移量<span>2x</span>處，依此類推。</p>
<p>複製增量：添加到復制的虛擬對象的偏移量上的值（請參見上文）（例如，在創建毛毛蟲時，您可能需要幾十個墊板，每個墊板都可以自動計算出不同的偏移量）。</p>
<p>對像大小：假人的大小。該參數僅具有視覺效果，沒有功能意義。</p>
<p>調整虛擬顏色：允許調整虛擬顏色</p>
<p><span> </span></p>
<p>接近傳感器<span>(Proximity sensors)</span></p>
<p><span>CoppeliaSim</span>提供了一種非常強大而有效的方法來模擬接近傳感器。用戶可以為幾乎所有類型的接近傳感器建模，從超聲波到紅外等等。允許此功能的場景對像是接近傳感器（與視覺傳感器不同），可以檢測可檢測到的實體。下圖說明了使用接近傳感器的仿真：</p>
<p><img alt="" height="228" src="https://s40723114.github.io/cd2020ag1/images/%E5%82%B3%E6%84%9F%E5%99%A81.jpg" width="600"/></p>
<p>接近傳感器通過<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>接近傳感器<span>]</span>添加到場景中。</p>
<p>接近傳感器使用的接近傳感器檢測例程也可以通過<span>Coppelia</span>幾何例程作為獨立例程使用。</p>
<p><span> </span></p>
<p>接近傳感器的類型和操作模式<span>(Proximity sensor types and mode of operation)</span></p>
<p>接近傳感器有<span>6</span>種不同類型，可以在很大程度上進行定制：</p>
<p>射線型：射線型接近傳感器非常適合非常簡單的接近傳感器建模或激光測距儀建模。它們是最快的接近傳感器。</p>
<p>隨機射線型：隨機射線型接近傳感器用作隨機掃描圓錐體的射線型傳感器。它的外觀與錐形接近傳感器類似。</p>
<p>金字塔型：金字塔型接近傳感器非常適合對帶有矩形檢測體積的接近傳感器進行簡單建模。他們很快。</p>
<p>圓柱型：圓柱型接近傳感器非常適合對具有旋轉體積的檢測體積的接近傳感器進行簡單建模。他們很快。</p>
<p>圓盤式：圓盤式接近傳感器可對具有旋轉掃描檢測體積的接近傳感器進行精確建模。根據所選的精度和操作模式，它們可能需要更多的計算量。</p>
<p>圓錐型：圓錐型接近傳感器允許對大多數接近傳感器進行最佳，最精確的建模。根據所選的精度和操作模式，它們可能需要更多的計算量。</p>
<p><span> <img alt="" height="141" src="https://s40723114.github.io/cd2020ag1/images/%E5%82%B3%E6%84%9F%E5%99%A82.jpg" width="631"/></span></p>
<p>接近傳感器以幾何上精確的方式運行：它們在其感測點（小球體）與任何干擾其檢測體積的可檢測實體之間執行精確的距離計算（像大多數傳感器一樣，它們在傳感體積邊緣之間不執行簡單的碰撞檢測其他模擬軟件，但在檢測範圍內進行精確的距離計算）。每個接近傳感器將計算以下最小距離：</p>
<p><img alt="" height="210" src="https://s40723114.github.io/cd2020ag1/images/%E5%82%B3%E6%84%9F%E5%99%A83.jpg" width="612"/></p>
<p>如果接近傳感器檢測到物體，則會激活觸發器，這將導致對觸發器回調函數的調用。</p>
<p>接近傳感器的計算結果可以通過圖形對象記錄。</p>
<p><span> </span></p>
<p>視覺傳感器<span>(Vision sensors)</span></p>
<p>除了接近傳感器之外，<span>CoppeliaSim</span>還提供另一種傳感器：視覺傳感器。視覺傳感器是可見的對象，其操作方式與攝影機對象非常相似：它們將渲染其視場中的對象，並在指定的閾值被過度拍攝或拍攝不足時觸發檢測。可以檢測可渲染實體的視覺傳感器應主要在顏色，光線或結構在檢測過程中起作用的情況下，在接近傳感器上使用（例如，紅外傳感器，或更籠統地說，對光敏感的傳感器（相機等））。但是，根據運行應用程序的圖形卡或場景對象的複雜程度，視覺傳感器可能會比接近傳感器慢一些。下圖說明了使用視覺傳感器的應用：</p>
<p><span> <img alt="" height="179" src="https://s40723114.github.io/cd2020ag1/images/%E8%A6%96%E8%A6%BA1.jpg" width="600"/></span></p>
<p>確保不要將視覺傳感器與相機混淆。以下是主要區別：</p>
<p>視覺傳感器具有固定的分辨率。相機沒有特定的分辨率（即，它會自動調整為視圖尺寸）。</p>
<p>視覺傳感器的圖像內容可通過<span>API</span>訪問，圖像處理可通過視覺回調函數進行處理。無法通過<span>API</span>直接獲得相機的圖像內容。</p>
<p>視覺傳感器通常比攝像頭需要更多的<span>CPU</span>時間並且運行速度較慢。</p>
<p>視覺傳感器只能顯示可渲染的對象。攝像機可以顯示所有對像類型。</p>
<p><span> </span></p>
<p>視覺傳感器類型和操作模式<span>(Vision sensor types and mode of operation)</span></p>
<p>視覺傳感器分為<span>2</span>種類型，可以針對不同目的進行調整：</p>
<p>正射投影型：正射投影型視覺傳感器的視場為矩形。它們非常適合於近距離紅外傳感器或激光測距儀。</p>
<p>透視投影型：透視投影型視覺傳感器的視場是梯形的。它們非常適合於相機型傳感器。</p>
<p><img alt="" height="176" src="https://s40723114.github.io/cd2020ag1/images/%E8%A6%96%E8%A6%BA2.jpg" width="393"/></p>
<p>視覺傳感器是可見的對象，可以像相機對像一樣進行瀏覽<span>[</span>彈出菜單<span>-&gt;</span>視圖<span>-&gt;</span>將視圖與選定的視覺傳感器相關聯<span>]</span>。有關更多詳細信息，另請參見頁面和視圖部分。</p>
<p><span> <img alt="" height="311" src="https://s40723114.github.io/cd2020ag1/images/%E8%A6%96%E8%A6%BA3.jpg" width="487"/></span></p>
<p>視覺傳感器功能強大，可以以多種靈活方式使用。例如，它們可以用於顯示來自外部應用程序或插件的靜止或運動圖像。插件還可以提供定制的圖像處理算法以及評估算法（例如觸發條件）。視覺回調函數代表了可以進行圖像處理以及可以生成觸發器的機制（可以對觸發器回調函數中的觸發器做出反應）。</p>
<p>視覺傳感器只能渲染（和檢測）可渲染的實體。</p>
<p>力傳感器<span>(Force sensors)</span></p>
<p>力傳感器最初是兩個形狀之間的剛性鏈接，能夠測量傳遞的力和扭矩。力傳感器的剛性是有條件的，在某種意義上，如果出現某種條件（例如，如果力或扭矩閾值被超過），則力傳感器可能會損壞。</p>
<p><span> <img alt="" height="252" src="https://s40723114.github.io/cd2020ag1/images/%E5%8A%9B1.jpg" width="477"/></span></p>
<p>力傳感器測量三個<span>3</span>對值，分別代表沿<span>x</span>，<span>y</span>和<span>z</span>軸施加在傳感器上的力以及圍繞<span>x</span>，<span>y</span>和<span>z</span>軸施加在傳感器上的扭矩：</p>
<p><img alt="" height="194" src="https://s40723114.github.io/cd2020ag1/images/%E5%8A%9B2.jpg" width="267"/></p>
<p>最初，力傳感器充當剛性連接。然而，在模擬過程中，當超過指定的力<span>/</span>扭矩閾值或滿足某些其他用戶定義的條件時，力傳感器可能會損壞。下圖說明了力傳感器的損壞狀態：</p>
<p><span> <img alt="" height="222" src="https://s40723114.github.io/cd2020ag1/images/%E5%8A%9B3.jpg" width="478"/></span></p>
<p>如果動態啟用了力傳感器，則它只能在仿真期間運行。 有關動態啟用的力傳感器的更多信息，另請參閱有關設計動態仿真的部分。 關節也能夠測量力或扭矩，但是只能沿/繞其z軸測量。</p>
<p>力傳感器通過[菜單欄-&gt;添加-&gt;力傳感器]添加到場景中。</p>
<p></p>
<p>路徑<span>(Paths)</span></p>
<p>路徑是定義空間中的路徑或軌蹟的對象。它可以用於各種任務，如下圖所示：</p>
<p><span> <img alt="" height="328" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%911.jpg" width="600"/></span></p>
<p>可以使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>路徑<span>]</span>將路徑對象添加到場景中。默認情況下，有兩個基本路徑可用：簡單的段類型路徑或圓形類型路徑。它們可以定向或縮放，但是通常這還不夠。用戶可以使用幾種方法來生成定制的路徑對象：</p>
<p>從文件導入路徑。</p>
<p>編輯路徑。</p>
<p>從形狀的邊緣生成路徑。有關詳細信息，請參見邊緣編輯模式。</p>
<p>路徑本身並沒有多大作用。它們通常與假人和其他物體結合使用以獲得所需的效果。要沿路徑移動對象，首先需要將虛擬對象分配給路徑，然後可以將對象附著到虛擬對象，該對象將遵循路徑的固有移動。有關更多詳細信息，請參閱關於虛擬變量的部分。</p>
<p>路徑是可渲染的對象，這意味著視覺傳感器可以看到路徑。但是，需要啟用路徑整形功能。可以在對象公共屬性中更改路徑的可渲染屬性。</p>
<p>某些路徑數據可以由圖形對象記錄。</p>
<p></p>
<p>路徑控制點和貝塞爾曲線點<span>(Control points and Bezier points)</span></p>
<p>路徑具有位置和方向分量（或通道），還可以另外具有描述速度曲線的分量。路徑由控制點定義，這些控制點將路徑描述為一系列鏈接的段。僅當選擇路徑時，控制點才可見：</p>
<p><span><img alt="" height="107" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%912.jpg" width="595"/><br/></span></p>
<p>路徑的第一個控制點（起點）表示為球體，其餘的控制點表示為立方體。路徑可以是開放的或封閉的。當關閉時，它變成循環的。</p>
<p><img alt="" height="102" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%913.jpg" width="292"/></p>
<p>每個控制點都具有可以更詳細地描述路徑的屬性：每個控制點都可以描述是否以及如何計算貝塞爾曲線。</p>
<p><span><img alt="" height="134" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%914.jpg" width="600"/><br/></span></p>
<p>默認情況下，貝塞爾曲線點始終可見（即使未選擇對象時），並顯示為紅色，綠色和藍色的小箭頭，指示貝塞爾曲線點的<span>x</span>軸，<span>y</span>軸和<span>z</span>軸（實際上是取向）。貝塞爾曲線部分由<span>3</span>個參數描述</p>
<p><span> <img alt="" height="170" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%915.jpg" width="419"/></span></p>
<p><span>Bezier</span>插值因子指示<span>Bezier</span>曲線部分的起點和終點，而<span>Bezier</span>點數指示曲線的詳細程度（或平滑度）。<span><span> </span>Bezier</span>點計數為<span>1</span>在技術上禁用了<span>Bezier</span>曲線插值機制，但為簡單起見，該控制點被稱為<span>Bezier</span>點。</p>
<p>可以在路徑編輯模式下手動調整控制點的位置和方向。但是不能單獨調整<span>Bezier</span>點的方向。它是自動計算的。默認情況下，貝塞爾曲線點的方向將遵循路徑曲率（如果啟用了自動方向選項），否則它們將與控制點的方向進行插值</p>
<p><span> <img alt="" height="170" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%916.jpg" width="419"/></span></p>
<p><span> </span></p>
<p>路徑位置和長度計算方法<span>(Path position and length calculation methods)</span></p>
<p>沿著路徑對象，可以定義固有位置。該位置（也稱為路徑位置）與路徑對象的位置不同。雖然路徑對象的位置是路徑對象原點的位置（在選擇路徑時顯示為白色線框立方體），但是路徑位置或固有路徑位置是沿路徑的位置值</p>
<p><span><img alt="" height="179" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%917.jpg" width="429"/> </span></p>
<p>路徑的<span>Bezier</span>點可以是不同的，也可以是重合的：想像一個焊接機器人，其末端執行器是焊接設備的尖端；在兩個連續的<span>Bezier</span>點之間，末端執行器可以：<span> </span></p>
<p>在不改變方向的情況下執行平移（即沿著直線）（兩個<span>Bezier</span>點是不同的，但方向相同）。</p>
<p>執行平移並更改方向（兩個<span>Bezier</span>點是不同的，並且方向不同）。</p>
<p>在不改變位置的情況下執行旋轉（即更改方向）（兩個<span>Bezier</span>點重合但方向不同）。</p>
<p>此外，在某些情況下，我們希望焊炬遵循預定的路徑，在某個特定位置暫停（例如，處理較大的焊接點），然後沿該路徑繼續前進。為了正確處理上述<span>3</span>種情況和特殊的暫停情況，重要的是能夠唯一地識別沿路徑（即路徑位置<span>*</span>）的任何位置<span>*</span>（廣義上的位置）以及路徑長度<span>*</span>（從更廣泛的意義上講是長度）。為此，用戶可以選擇幾種位置計算方法：</p>
<p><span> </span></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積線性變化。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="https://s40723114.github.io/cd2020ag1/images/%E5%85%AC%E5%BC%8F1.jpg" width="92"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積角度<span>**</span>變化。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="https://s40723114.github.io/cd2020ag1/images/%E5%85%AC%E5%BC%8F2.jpg" width="107"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（線性變化<span>+</span>角度<span>**</span>變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="https://s40723114.github.io/cd2020ag1/images/%E5%85%AC%E5%BC%8F3.jpg" width="139"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積最大值（線性變化，角度<span>**</span>變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="https://s40723114.github.io/cd2020ag1/images/%E5%85%AC%E5%BC%8F4.jpg" width="169"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（線性變化，如果不為零，否則為角度<span>**</span>）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="https://s40723114.github.io/cd2020ag1/images/%E5%85%AC%E5%BC%8F5.jpg" width="328"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（角度<span>**</span>變化，如果不為零，否則為線性變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="https://s40723114.github.io/cd2020ag1/images/%E5%85%AC%E5%BC%8F6.jpg" width="347"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的（線性變化，角度<span>**</span>變化）的累積歐幾里德距離。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="https://s40723114.github.io/cd2020ag1/images/%E5%85%AC%E5%BC%8F7.jpg" width="145"/></p>
<p><span> </span></p>
<p>其中Δ<span>l</span>和Δα分別是兩個連續的<span>Bezier</span>點之間的線性和角度變化。角度<span>**</span>變化是規則角度變化乘以角度係數<span>c</span>。<span><span> </span>c</span>稱為角度到線性的轉換係數，並且可以將角度值和線性值組合在一起。這意味著沿路徑的位置<span>*</span>或路徑長度<span>*</span>始終以線性單位（例如米）給出，而與上面選擇的位置計算方法無關。</p>
<p>默認情況下，紅色標記的項為零。該術語可以看作是<span>Bezier</span>點（或路徑控制點）的虛擬距離或第四坐標（即每個<span>Bezier</span>點將由方向和位置（<span>x</span>，<span>y</span>，<span>z</span>，<span>w</span>）定義，其中<span>w</span>是第四坐標）。這對於沿路徑歸檔暫停點很有用。是兩個連續的<span>Bezier</span>點之間的虛擬距離變化。<span><span> </span>d</span>是虛擬距離變化的比例因子（例如，如果<span>d</span>加倍，則所有暫停點的暫停持續時間將是兩倍）。為簡化起見，在以下內容中我們將不再提及該術語並將其設為零。</p>
<p>以下示例闡明了位置和長度計算概念：</p>
<p><span> <img alt="" height="256" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%918.jpg" width="600"/></span></p>
<p><img alt="" height="220" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%919.jpg" width="450"/></p>
<p></p>
<p><img alt="" height="205" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%9110.jpg" width="600"/></p>
<p><img alt="" height="192" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%9111.jpg" width="450"/></p>
<p>要歸檔沿路徑的特定點處的運動暫停，請執行以下操作：創建<span>3</span>個相同的路徑控制點（位置和方向完全重合），並為中間控制點指定一個虛擬距離值，該值不得為零。在下面的示例中，在<span>3</span>個重合點的虛擬距離為<span>2</span>（在第一和中間重合控制點之間為<span>1</span>，在中間和第三重合控制點之間為<span>1</span>）。如果某個對像以每秒<span>1</span>米的速度沿路徑行進，則它將在重合的控制點處記錄<span>2</span>秒的暫停：</p>
<p><span> <img alt="" height="213" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%9112.jpg" width="285"/></span></p>
<p><span> </span></p>
<p>沿路徑運動<span>(Movement along a Path)</span></p>
<p>當前固有路徑位置在路徑上顯示為紅色球形（如果啟用了路徑位置顯示）。在模擬過程中，可以隨時使用<span>sim.setPathPosition</span>來控制球沿路徑的位置。確保了解如何計算路徑位置或路徑長度。</p>
<p>要實際使對象沿路徑移動，首先需要將對象附加到虛擬對象，然後分配虛擬對像以遵循路徑位置（帶有可選的偏移量）。</p>
<p><span> </span></p>
<p>導入和導出路徑<span>(Importing and exporting paths)</span></p>
<p>路徑導入<span>/</span>導出功能可在<span>CSV</span>文件（逗號分隔值）上運行，該<span>CSV</span>文件可以用簡單的文本編輯器創建或讀取，但也可以輕鬆地導入<span>/</span>導出到<span>Microsoft Excel</span>等應用程序中。</p>
<p>導入路徑</p>
<p><span>CoppeliaSim</span>的導入功能（<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導入<span>-&gt; CSV</span>的路徑<span>...]</span>）逐行讀取值，其中每行對應一個控制點。每行應採用以下格式設置：</p>
<p><span> </span><span>x</span>，<span>y</span>，<span>z</span>，<span>alpha</span>，<span>beta</span>，<span>gamma</span>，<span>relativeVelocity</span>，<span>BezierPointCount</span>，<span>interpolationFactor1</span>，<span>interpolationFactor2</span>，</p>
<p><span> virtualDistance</span>，<span>auxiliaryFlags</span>，<span>auxiliaryChannel1</span>，<span>auxiliaryChannel2</span>，<span>auxiliaryChannel3</span>，<span>auxiliaryChannel4</span></p>
<p>其中內容相對應的意思：<span> </span></p>
<p>（<span>x</span>，<span>y</span>，<span>z</span>）表示控制點在<span>METERS</span>中的位置</p>
<p>（α，β，γ）表示控制點的方向，以度數表示為歐拉角。默認值為（<span>0,0,0</span>）。</p>
<p>相對速度已棄用。設為<span>1.0</span></p>
<p><span>BezierPointCount</span>是控制點所需的<span>Bezier</span>點數。默認值為<span>1</span>。</p>
<p><span>InterpolationFactor1</span>和<span>InterpolationFactor2</span>是在路徑控制點和<span>Bezier</span>點部分中描述的插值因子。默認值為<span>0.5</span></p>
<p><span>VirtualDistance</span>：虛擬距離值，添加到該控制點位置的路徑長度上，另請參見路徑位置或路徑長度計算方法。默認值為<span>0.0</span></p>
<p>輔助標誌：可以用於各種目的的標誌，可以通過<span>sim.getDataOnPath</span>函數進行查詢。默認值為<span>0</span>。</p>
<p>輔助通道<span>1-4</span>：可以用於各種目的的值，可以通過<span>sim.getDataOnPath</span>函數進行查詢。默認值為<span>0.0</span></p>
<p>除了前三個值（控制點位置坐標）外，所有其他值都可以省略，在這種情況下，將應用默認值。</p>
<p><span> </span>導出路徑</p>
<p>通過選擇路徑，然後單擊<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導出<span>-&gt;</span>選定路徑為<span>CSV ...]</span>，可以導出路徑的控制點。在這種情況下，導出格式與前面描述的路徑導入格式相同。</p>
<p>也可以通過選擇路徑，然後單擊<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導出<span>-&gt;</span>所選路徑的<span>Bezier</span>曲線為<span>CSV ...]</span>來導出路徑的<span>Bezier</span>點。在這種情況下，創建的文件（導出的文件）中的每一行都對應一個<span>Bezier</span>點，並包含以下值：</p>
<p><span> </span><span>x</span>，<span>y</span>，<span>z</span>，<span>alpha</span>，<span>beta</span>，<span>gamma</span>，相對速度，虛擬距離，輔助標記，輔助通道<span>1</span>，輔助通道<span>2</span>，<span>assistantChannel3</span>，<span>auxiliaryChannel4</span><span> </span></p>
<p><span> </span></p>
<p>路徑編輯模式<span>(Path edit mode)</span></p>
<p>初步說明：路徑編輯模式是一種方便且功能齊全的編輯路徑對象的方法。但是，可以在不進入用於最小化路徑修改的路徑編輯模式的情況下移動和擦除單個路徑點（選擇單個路徑點時，請確保沒有選擇除路徑之外的其他對象）。</p>
<p>可以通過單擊相應的工具欄按鈕來訪問路徑編輯模式：</p>
<p><span><img alt="" height="37" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%91%E7%B7%A8%E8%BC%AF%E4%B8%80.jpg" width="38"/><br/></span></p>
<p><span>[</span>路徑編輯模式工具欄按鈕<span>]</span><span> </span></p>
<p>上面的工具欄按鈕僅在選擇路徑後才有效。在路徑編輯模式下，窗口中通常顯示場景層次結構的部分用於將路徑控制點顯示為列表。可以使用鼠標選擇列表中的項目，就像在層次結構窗口中的對像一樣。</p>
<p><span> <img alt="" height="478" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%91%E7%B7%A8%E8%BC%AF%E4%BA%8C.jpg" width="600"/></span></p>
<p><span>[</span>路徑編輯模式<span>]</span></p>
<p>現在可以像常規對像一樣選擇單個控制點。最後選擇的控制點以白色顯示，其他選擇的控制點以黃色顯示，未選擇的控制點以藍色顯示。以類似的方式，可以使用鼠標直接平移控制點，方法是使用工具欄的對象<span>/</span>項目平移工具欄按鈕在與視圖方向垂直的平面中平移所選的控制點：</p>
<p><span><img alt="" height="37" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%91%E7%B7%A8%E8%BC%AF%E4%B8%89.jpg" width="38"/><br/></span></p>
<p><span>[</span>對象<span>/</span>項目翻譯工具欄按鈕<span>]</span></p>
<p>在路徑編輯模式下，將顯示路徑編輯模式對話框：</p>
<p><span><img alt="" height="478" src="https://s40723114.github.io/cd2020ag1/images/%E8%B7%AF%E5%BE%91%E7%B7%A8%E8%BC%AF%E5%9B%9B.jpg" width="396"/><br/></span></p>
<p><span>[</span>控制點屬性對話框<span>]</span></p>
<p>路徑已關閉：如果選中，則路徑的最後一個控制點將鏈接到其第一個控制點，以關閉路徑並使其循環運行。閉合路徑至少需要<span>3</span>個控制點。</p>
<p>路徑是平坦的：如果選中，則所有控制點（以及隨後的所有<span>Bezier</span>點）都將約束到路徑對象的本地參考系的<span>z = 0</span>平面。</p>
<p>自動定向：如果啟用，則將自動計算所有控制點和貝塞爾曲線點的定向，以使該點的<span>z</span>軸沿著路徑，其<span>y</span>軸指向其曲率向外（如果啟用了<span>x up</span>，則<span>y -</span>軸沒有特別限制）。如果禁用，則用戶確定控制點的方向，貝塞爾曲線點的方向將從路徑的控制點的方向內插。</p>
<p>保持<span>x</span>向上：如果選中，則自動定向功能將使每個<span>Bezier</span>點的<span>z</span>軸沿路徑對齊，並使其<span>x</span>軸沿路徑對象的<span>z</span>軸指向。</p>
<p>清除選擇：清除控制點的選擇。</p>
<p>反轉選擇：反轉控制點的選擇狀態。</p>
<p>製作虛擬對象：在選擇控制點的位置生成虛擬對象。</p>
<p>貝塞爾曲線插值因子<span>1/2</span>：有關詳細信息，請參見控制點和貝塞爾曲線部分。</p>
<p>貝塞爾曲線點數：有關詳細信息，請參見控制點和貝塞爾曲線部分。</p>
<p>虛擬距離：有關詳細信息，請參見關於沿路徑運動的部分。</p>
<p>輔助標誌：可以用於各種目的的標誌，可以通過<span>sim.getDataOnPath</span>函數進行查詢。</p>
<p>輔助通道<span>1-4</span>：可以用於各種目的的值，可以通過<span>sim.getDataOnPath</span>函數進行查詢。</p>
<p>為了精確定位控制點，請使用坐標和變換對話框。如果要編輯控制點的方向，請確保禁用路徑的“自動方向”選項（默認情況下啟用該選項）。</p>
<p>常規鍵組合（即<span>ctrl-c</span>，<span>ctrl-v</span>，<span>delete</span>和<span>ctrl-x</span>）支持複製<span>/</span>粘貼<span>/</span>刪除<span>/</span>剪切操作。確保主視圖具有焦點，以便按鍵起作用。如果未選擇任何控制點，則黏貼操作會將復制的控制點黏貼到控制點列表的開頭，否則將黏貼到選定的控制點之後（確保不超過一個控制點）。在此階段選擇）。也可以通過彈出菜單或通過<span>[</span>主菜單<span>-&gt;</span>編輯<span>]</span>訪問相同的複制<span>/</span>黏貼<span>/</span>刪除<span>/</span>剪切功能。其他操作包括：</p>
<p>在路徑的開頭插入新的路徑點<span>/</span>選擇後插入新的路徑點：如果未選擇任何控制點，則在路徑的開頭插入新的控制點；否則，在當前選擇之後插入新的控制點（請確保沒有其他內容）在這種情況下，選擇一個控制點）。</p>
<p>從貝塞爾曲線創建新路徑：使用當前路徑的貝塞爾點生成一個新的路徑對象，即新路徑的控制點將為當前路徑的貝塞爾點。</p>
<p><span> </span></p>
<p>超頻樹<span>(OC trees)</span></p>
<p><span>OC</span>樹是代表空間分區的對象。它由樹形數據結構組成，其中每個節點正好具有八個子代。佔用的葉節點表示為體素。<span><span> </span>OC</span>樹可用於為形狀或點雲提供簡化的表示，或者可充當佔用網格<span>/</span>空間：</p>
<p><span><img alt="" height="393" src="https://s40723114.github.io/cd2020ag1/images/%E6%A8%B9%E6%9C%A83.jpg" width="527"/><br/></span></p>
<p><span>OC</span>樹是可碰撞，可測量和可檢測的對象。這意味著<span>OC</span>樹：</p>
<p>可用於與其他可碰撞對象的碰撞檢測。</p>
<p>可與其他可測量對像一起用於最小距離計算。</p>
<p>可以被接近傳感器檢測到。</p>
<p><span>OC</span>樹可以使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt; OC</span>樹<span>]</span>添加到場景中，並通過<span>OC</span>樹屬性進行編輯。</p>
<p><span>CoppeliaSim</span>中可用的<span>OC</span>樹計算（即碰撞，距離和接近傳感器計算）也可以通過<span>Coppelia</span>幾何例程作為獨立例程使用。</p>
<p><span> </span></p>
<p><span>OC</span>樹屬性<span>(OC tree properties)</span></p>
<p><span>OC</span>樹屬性是場景對象屬性對話框的一部分，該對話框位於<span>[</span>菜單欄<span>-&gt;</span>工具<span>-&gt;</span>場景對象屬性<span>]</span>。您還可以通過雙擊場景層次結構中的對像圖標或單擊其工具欄按鈕來打開對話框：</p>
<p><span> <img alt="" height="37" src="https://s40723114.github.io/cd2020ag1/images/%E6%A8%B9%E6%9C%A81.jpg" width="38"/></span></p>
<p><span>[</span>場景對象屬性工具欄按鈕<span>]</span></p>
<p>在場景對象屬性對話框中，單擊<span>OC</span>樹按鈕以顯示<span>OC</span>樹對話框（僅當最後選擇的是<span>OC</span>樹時才會顯示<span>OC</span>樹按鈕）。該對話框顯示最後選擇的<span>OC</span>樹的設置和參數：</p>
<p><span> <img alt="" height="342" src="https://s40723114.github.io/cd2020ag1/images/%E6%A8%B9%E6%9C%A82.jpg" width="380"/></span></p>
<p><span>[OC</span>樹對話框<span>]</span></p>
<p>體素大小：<span>OC</span>樹體素的大小。大小越小，用於<span>OC</span>樹數據結構的內存就越大。</p>
<p>插入選定的可見對象：允許基於選定的可見對象插入體素。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標<span>OC</span>樹對象。</p>
<p>減去選定的可見對象：允許基於選定的可見對象刪除體素。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標<span>OC</span>樹對象。</p>
<p>清除<span>OC</span>樹：從<span>OC</span>樹中刪除所有體素。</p>
<p>體素具有隨機顏色：每個體素將具有隨機顏色。</p>
<p>顯示<span>OC</span>樹結構：顯示<span>OC</span>樹數據結構，主要用於調試目的。</p>
<p>顏色是自發光的：體素將以自發光的顏色顯示。</p>
<p>顯示點而不是體素：對於包含大量體素的<span>OC</span>樹，顯示可能會很慢。在這種情況下，您可以顯示像素體素，而不是立方體素。</p>
<p>調整下一次插入的顏色：允許選擇新的顏色，該顏色將用於新的體素插入。<span><br/><br/></span></p>
<p><span></span></p>
<p>點雲<span>(Point clouds)</span></p>
<p>點雲是充當基於<span>OC</span>樹的點容器的對象：</p>
<p><span> <img alt="" height="416" src="https://s40723114.github.io/cd2020ag1/images/%E9%9B%B23.jpg" width="599"/></span></p>
<p>點雲是可碰撞，可測量和可檢測的對象。這意味著點雲：</p>
<p>可用於與其他基於體積的可碰撞對象（例如<span>OC</span>樹）的碰撞檢測。</p>
<p>可與其他可測量對像一起用於最小距離計算。</p>
<p>可以被接近傳感器檢測到。</p>
<p>可以使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>點雲<span>]</span>將點雲添加到場景，並通過點雲屬性進行編輯。</p>
<p><span>CoppeliaSim</span>中可用的點雲計算（即碰撞，距離和接近傳感器計算）也可以通過<span>Coppelia</span>幾何例程作為獨立例程使用。</p>
<p><span> </span></p>
<p>點雲屬性<span>(Point cloud properties)</span></p>
<p>點雲屬性是場景對象屬性對話框的一部分，該對話框位於<span>[</span>菜單欄<span>-&gt;</span>工具<span>-&gt;</span>場景對象屬性<span>]</span>。您還可以通過雙擊場景層次結構中的對像圖標或單擊其工具欄按鈕來打開對話框：</p>
<p><span> <img alt="" height="37" src="https://s40723114.github.io/cd2020ag1/images/%E9%9B%B21.jpg" width="38"/></span></p>
<p><span>[</span>場景對象屬性工具欄按鈕<span>]</span></p>
<p>在場景對象屬性對話框中，單擊“點雲”按鈕以顯示<span>OC</span>樹對話框（“點雲”按鈕僅在最後選擇的是點雲時出現）。該對話框顯示最後選擇的點雲的設置和參數：</p>
<p><span> <img alt="" height="413" src="https://s40723114.github.io/cd2020ag1/images/%E9%9B%B22.jpg" width="380"/></span></p>
<p><span>[</span>點雲對話框<span>]</span></p>
<p>不要使用<span>OC</span>樹計算。結構：默認情況下，點雲使用類似於<span>OC</span>樹的計算結構進行有效的點操作。此結構可能會減慢插入點和刪除點的速度。如果啟用此項目，則點插入將更加有效，但是點雲將不再可碰撞，不可測量或不可檢測，並且某些其他操作也可能會受到限制。您始終可以在以後的階段或通過<span>sim.setPointCloudOptions</span>切換此項目。</p>
<p>最高體素大小：將包含點的<span>OC</span>樹體素的最大大小。大小越小，此點雲所基於的<span>OC</span>樹數據結構將使用的內存就越大。</p>
<p>最高點數<span>/</span>體素：單個<span>OC</span>樹體素可以包含的最大點數。如果需要在此類體素中存儲更多點，它將被拆分為<span>8</span>個子體素，直到滿足約束條件為止。為了有效地進行碰撞檢測，距離計算和接近傳感器檢測，建議在單個體素中存儲大約<span>10-20</span>個點。</p>
<p>插入選定的可見對象：允許基於選定的可見對象插入點。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標點雲對象。形狀將事先轉換為具有指定構建分辨率的臨時<span>OC</span>樹。插入公差項允許通過指定用於確定是否插入點的最小距離公差來避免重複的點。插入公差<span>&gt; 0.0</span>時，點插入將變慢。</p>
<p>減去選定的可見對象：允許基於選定的可見對象減去點。僅考慮虛擬變量，超頻樹和點雲。選擇要減去的所有對象，然後最後選擇目標點雲對象。假人和點雲將使用減法公差值來標識要刪除的點。</p>
<p>清除點雲：從點雲中刪除所有點。</p>
<p>點具有隨機顏色：每個點將具有隨機顏色。</p>
<p>顯示<span>OC</span>樹結構：顯示底層<span>OC</span>樹數據結構，主要用於調試目的。</p>
<p>顏色是自發光的：點將以自發光的顏色顯示。</p>
<p>點顯示比例：包含大量點的點雲可能會減慢渲染速度。通過將比率設置為小於<span>1</span>，將為每個包含點的<span>OC</span>樹體素顯示更少的點數。這僅對顯示<span>/</span>渲染的圖像有影響。</p>
<p>點大小：點的大小，以像素為單位。</p>
<p>調整下一次插入的顏色：允許選擇一種新的顏色，該顏色將用於新的點插入。</p>
<p><span> </span></p>
<p>外部控制器教程<span>(External controller tutorial)</span></p>
<p>在<span>CoppeliaSim</span>中，有幾種方法可以控制機器人或仿真：</p>
<p>最方便的方法是編寫一個子腳本來處理給定機器人或模型的行為。這是最方便的方法，因為子腳本直接附加到場景對象，它們將與相關的場景對像一起復制，它們不需要使用外部工具進行任何編譯，它們可以在線程或非線程模式下運行，它們可以通過自定義<span>Lua</span>函數或<span>Lua</span>擴展庫進行擴展。使用子腳本的另一個主要優點是：與本節中提到的後<span>3</span>種方法（即使用常規<span>API</span>）一樣，沒有通信延遲，並且子腳本是應用程序主線程的一部分（固有的同步操作）。但是，編寫腳本有幾個缺點：您無法選擇編程語言，不能擁有最快的代碼，並且除了<span>Lua</span>擴展庫之外，無法直接訪問外部函數庫。</p>
<p>可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使用回調機制，自定義<span>Lua</span>函數註冊，當然還可以訪問外部函數庫。插件通常與子腳本結合使用（例如，插件註冊自定義的<span>Lua</span>函數，當從子腳本中調用時，該<span>Lua</span>函數將回調特定的插件函數）。使用插件的主要優勢還在於，與本節中提到的後<span>3</span>種方法（即使用常規<span>API</span>）一樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。另請參閱插件教程。</p>
<p>控制機器人或模擬的第三種方法是編寫依賴於遠程<span>API</span>的外部客戶端應用程序。如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。這也使您可以使用與運行真實機器人完全相同的代碼來控制仿真或模型（例如虛擬機器人）。遠程<span>API</span>有兩個版本：基於<span>B0</span>的遠程<span>API</span>和舊版遠程<span>API</span>。</p>
<p>控制機器人或仿真的第五種方法是通過<span>ROS</span>節點。<span><span> </span>ROS</span>與遠程<span>API</span>相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程<span>API</span>非常輕巧且快速，但它僅允許與<span>CoppeliaSim</span>通信。另一方面，<span>ROS</span>允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。但是，它比遠程<span>API</span>重並且更複雜。有關詳細信息，請參閱<span>ROS</span>接口。</p>
<p>控制機器人或模擬的第六種方法是通過<span>BlueZero</span>（<span>BØ</span>）節點。與<span>ROS</span>類似，<span>BlueZero</span>是使多個分佈式進程相互通信的一種便捷方法，並且是一種輕量級的跨平台解決方案。有關詳細信息，請參考<span>BlueZero</span>界面。</p>
<p>控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與<span>CoppeliaSim</span>插件或<span>CoppeliaSim</span>腳本進行通信。選擇編程語言（可以是任何一種語言）和靈活性是兩個主要優點。同樣，控制代碼也可以在機器人或其他計算機上運行。但是，與使用遠程<span>API</span>的方法相比，這種控制仿真或模型的方法更加乏味。</p>
<p>有<span>8</span>個與本教程相關的場景文件：</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaScript</span>：一個機器人是通過非線程子腳本控制的，另一個是通過線程子腳本控制的。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaPlugin</span>：機器人是通過插件控制的。</p>
<p><span>scenes / controlTypeExamples / controlViaB0RemoteApi</span>：通過基於<span>B0</span>的遠程<span>API</span>來控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaLegacyRemoteApi</span>：通過舊版遠程<span>API</span>控制機器人。</p>
<p><span>scenes / controlTypeExamples / controlViaB0</span>：通過<span>BlueZero</span>界面控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaRos</span>：通過<span>ROS</span>接口控制機器人。</p>
<p><span>scenes / controlTypeExamples / controlViaRos2</span>：通過<span>ROS2</span>接口控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaTcp</span>：通過<span>LuaSocket</span>和<span>TCP</span>控制機器人。</p>
<p><img alt="" height="581" src="https://s40723114.github.io/cd2020ag1/images/%E8%BC%B8%E5%87%BA.jpg" width="752"/></p>
<p>在所有<span>8</span>種情況下，都使用子腳本，主要是為了與外界建立鏈接（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給它）。有兩種其他方法可以控制機器人，模擬或模擬器本身：使用自定義腳本或附加組件。但是，不建議將它們用於控制，而應使用在模擬未運行時處理功能。</p>
<p>例如，鏈接到場景控制的<span>ViaB0RemoteApi.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p>使用某些對象句柄作為參數啟動控制器應用程序（<span>bubbleRobClient_b0RemoteApi</span>）。基於對象<span>B0</span>的遠程<span>API</span>的服務器功能由對象<span>b0RemoteApiServer</span>提供。</p>
<p>作為另一個示例，鏈接到場景控制的<span>ViaRos.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p>檢查是否已加載<span>CoppeliaSim</span>的<span>ROS</span>接口</p>
<p>使用某些主題名稱或對象句柄作為參數啟動控制器應用程序（<span>rosBubbleRob</span>）</p>
<p>然而，作為另一個示例，鏈接到場景控制的<span>ViaTcp.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p>搜索空閒的套接字連接端口</p>
<p>使用所選的連接端口作為參數啟動控制器應用程序（<span>bubbleRobServer</span>）</p>
<p>本地連接到控制器應用程序</p>
<p>在每次仿真過程中，將傳感器值發送到控制器，並從控制器讀取所需的電機值</p>
<p>在每次模擬過程中，將所需的電機值應用於機器人的關節</p>
<p>運行模擬，然後復制並粘貼機器人：您將看到重複的機器人將直接運行，因為附加的子腳本負責啟動各自外部應用程序的新實例，或調用適當的插件函數。</p>
<h1>Work3</h1>
<h2>VirtualBox</h2>
<p>設定IPV4</p>
<p><img alt="" height="648" src="http://mde.tw/cdaw15-1/images/IPV4.jpg" width="1152"/></p>
<p>設定IPV6</p>
<p><img alt="" height="648" src="http://mde.tw/cdaw15-1/images/IPV6.jpg" width="1152"/></p>
<p>在virtualbox-Ubunto中進入cd2020pj1( cd /tmp/cd2020pj1)</p>
<p>輸入 python3 wsgi.py(Gpython3 wsgi.py(ifconfig ifconfig 中近端需與wsgi.pyfig 中近端需與wsgi.py中相同)</p>
<p><img alt="" height="648" src="http://mde.tw/cdaw15-1/images/port%E8%99%9F.jpg" width="1152"/></p>
<p>獲得網址</p>
<p><img alt="" height="648" src="http://mde.tw/cdaw15-1/images/%E7%B6%B2%E5%9D%80.jpg" width="1152"/></p>
<p>在firefox中輸入網址獲得以下畫面表示連線成功</p>
<p><img alt="" height="712" src="http://mde.tw/cdaw15-1/images/%E7%B6%B2%E7%AB%99.jpg" width="1266"/></p>
<p></p>
<h1><span>問題解決</span></h1>
<p><span>在過程中所遇到的問題及解決辦法</span></p>
<h2><span>push衝突</span></h2>
<p><span>在push的時候總會遇到相互衝突的時候而產生類似下面的文字提示</span></p>
<p><span>error: failed to push some refs to 'https://github.com/mdecourse/cdaw13-1'<br/>hint: Updates were rejected because the remote contains work that you do<br/>hint: not have locally. This is usually caused by another repository pushing<br/>hint: to the same ref. You may want to first integrate the remote changes<br/>hint: (e.g., 'git pull ...') before pushing again.<br/>hint: See the 'Note about fast-forwards' in 'git push --help' for details.</span></p>
<p><span>解決辦法:發生原因是來自於他人上傳而產生新檔案自己沒有這個新檔案</span></p>
<p><span>所以只要git pull再git push即可</span></p>